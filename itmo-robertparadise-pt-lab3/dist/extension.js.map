{"version":3,"file":"extension.js","mappings":"uuBAUA,oBAAyBA,GACrB,IAAIC,EAAaC,EAAOC,SAASC,gBAAgB,6BAA6B,KAC7E,MAAMC,EAAWH,EAAOI,UAAUC,SAAW,IAAMC,EAC7CC,EAAgBP,EAAOI,UAAUC,SAAW,IAAMG,EAGxDC,EAAGC,SAASP,EAAU,QAAQ,CAACQ,EAAKC,KAChC,GAAID,EAEA,YADAX,EAAOa,OAAOC,iBAAiB,iCAInC,MAAMC,EAAYC,KAAKC,MAAML,GAC7BM,EAAclB,EAAOI,UAAUC,SAAUE,EAAeQ,EAAU,GACvE,IAGAjB,EAAQqB,cAAcC,KAAKrB,EAC/B,EAwFA,wBAA8B,EApH9B,kBACA,YACA,YAEMO,EAAiB,iBACjBE,EAAmB,YAgCzB,SAASU,EAAcG,EAA8Bd,EAAuBQ,GAC3E,GAAIM,EAID,IAAI,MAAMC,KAAOP,EAAW,CAC9B,MAAMQ,EAAQR,EAAUO,GACxB,GAAoB,iBAAVC,EAAoB,CAG7B,MAAMC,EAAaC,EAAKC,KAAKL,EAAUC,GAE5Bb,EAAGkB,WAAWH,IACff,EAAGmB,UAAUJ,GAGjBN,EAAcM,EAAYjB,EAAegB,EAChD,MACK,GAAoB,iBAAVA,EAAoB,CAGlC,GAAc,MAAVA,EAEH,YADAvB,EAAOa,OAAOC,iBAAiB,gCAAgCS,MAIhEM,EAAeR,EAAUd,EAAegB,EAAOD,EAChD,CACE,CACJ,CAKA,SAASO,EAAeR,EAAkBd,EAAuBuB,EAAkBC,GAClFtB,EAAGuB,QAAQzB,EAAe,CAAC0B,eAAe,IAAO,CAACtB,EAAKuB,KACtD,GAAIvB,EACHX,EAAOa,OAAOC,iBAAiB,2BAA6BH,QAK7D,IAAK,MAAMwB,KAAOD,EAAS,CAC1B,MAAME,EAAkBX,EAAKC,KAAKnB,EAAe4B,EAAIE,MAGrD,GAAIF,EAAIE,OAASP,GAAyB,MAAbA,EAC5B,GAAIK,EAAIG,cAAe,CACtB,IAAIC,EAEHA,EADe,MAAbT,EACQL,EAAKC,KAAKL,EAAUc,EAAIE,MAGxBZ,EAAKC,KAAKL,EAAUS,GAG/BS,EAAUA,EAAQC,QAAQ,YAAaT,GAEvCQ,EAAUA,EAAQC,QAAQ,WAAY,IAEjC/B,EAAGkB,WAAWY,IAClB9B,EAAGmB,UAAUW,GAGdV,EAAeU,EAASH,EAAiB,IAAKL,EAC/C,KACK,CACJ,IAAIU,EAAYN,EAAIE,KAAKG,QAAQ,YAAaT,GAE9CU,EAAYA,EAAUD,QAAQ,WAAY,IACrC/B,EAAGkB,WAAWF,EAAKC,KAAKL,EAAUoB,KACtChC,EAAGiC,aAAajB,EAAKC,KAAKnB,EAAe4B,EAAIE,MAAOZ,EAAKC,KAAKL,EAAUoB,GAE1E,CAEF,IAEF,C,UClHAE,EAAOC,QAAUC,QAAQ,S,UCAzBF,EAAOC,QAAUC,QAAQ,K,UCAzBF,EAAOC,QAAUC,QAAQ,O,GCCrBC,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,CAAC,GAOX,OAHAQ,EAAoBH,GAAUI,KAAKV,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,OACf,CCnB0BI,CAAoB,K","sources":["webpack://itmo-robertparadise-pt-lab3/./src/extension.ts","webpack://itmo-robertparadise-pt-lab3/external commonjs \"vscode\"","webpack://itmo-robertparadise-pt-lab3/external node-commonjs \"fs\"","webpack://itmo-robertparadise-pt-lab3/external node-commonjs \"path\"","webpack://itmo-robertparadise-pt-lab3/webpack/bootstrap","webpack://itmo-robertparadise-pt-lab3/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst STRUCTURE_FILE = 'structure.json';\nconst TEMPLATES_FOLDER = 'templates';\n\n/**\n * Activates the extension and registers the 'extension.createStructure' command.\n */\nexport function activate(context: vscode.ExtensionContext) {\n    let disposable = vscode.commands.registerCommand('extension.createStructure', () => {\n    \tconst filePath = vscode.workspace.rootPath + '/' + STRUCTURE_FILE;\n    \tconst templatesPath = vscode.workspace.rootPath + '/' + TEMPLATES_FOLDER;\n\n    \t// Read structure file\n    \tfs.readFile(filePath, 'utf8', (err, data) => {\n        \tif (err) {\n            \tvscode.window.showErrorMessage('Error reading structure file!');\n            \treturn;\n        \t}\n      \n        \tconst structure = JSON.parse(data);\n        \tcreateFolders(vscode.workspace.rootPath, templatesPath, structure);\n\t\t});\n    });\n\n    context.subscriptions.push(disposable);\n}\n\n/**\n * Recursively creates folders based on the structure provided.\n * If a value is an object, it creates a folder. If a value is a string representing a template, it creates with that template.\n * @param basePath The base path to create the folders in.\n * @param templatesPath The path to the templates folder.\n * @param structure The structure object defining the folders to create.\n */\nfunction createFolders(basePath: string | undefined, templatesPath: string, structure: any) {\n\tif(!basePath){\n\t\treturn;\n\t}\n\n    for(const key in structure) {\n\t\tconst value = structure[key];\n\t\tif(typeof value === \"object\") {\n\t\t\t// If it's no template\n\n\t\t\tconst folderPath = path.join(basePath, key);\n    \n        \tif (!fs.existsSync(folderPath)) {\n            \tfs.mkdirSync(folderPath);\n        \t}\n\n        \tcreateFolders(folderPath, templatesPath, value);\n\t\t}\n\t\telse if(typeof value === \"string\") {\n\t\t\t// If it's a template\n\n\t\t\tif (value === \"_\") {\n\t\t\t\tvscode.window.showErrorMessage(`Error invalid template name \"${value}\"`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTemplate(basePath, templatesPath, value, key);\n\t\t}\n    }\n}\n\n/**\n * Create given template.\n */\nfunction createTemplate(basePath: string, templatesPath: string, template: string, fileName: string) {\n\tfs.readdir(templatesPath, {withFileTypes: true}, (err, objects) => {\n\t\tif (err) {\n\t\t\tvscode.window.showErrorMessage('Error reading directory:' + err);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check all objects in the folder\n\t\tfor (const obj of objects) {\n\t\t\tconst newTemplatePath = path.join(templatesPath, obj.name);\n\t\t\t// If template = \"_\" then we are already in template processing\n\t\t\t// If template != \"_\" then we need find given template\n\t\t\tif (obj.name === template || template === '_') {\n\t\t\t\tif (obj.isDirectory()) {\n\t\t\t\t\tlet newPath;\n\t\t\t\t\tif(template === '_') {\n\t\t\t\t\t\tnewPath = path.join(basePath, obj.name);\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewPath = path.join(basePath, template);\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPath = newPath.replace(/\\(name\\)/g, fileName);\n\t\t\t\t\t// remove [...] constructs\n\t\t\t\t\tnewPath = newPath.replace(/\\[.*?\\]/g, '');\n\n\t\t\t\t\tif (!fs.existsSync(newPath)) {\n\t\t\t\t\t\tfs.mkdirSync(newPath);\n\t\t\t\t\t}\n\n\t\t\t\t\tcreateTemplate(newPath, newTemplatePath, '_', fileName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet finalName = obj.name.replace(/\\(name\\)/g, fileName);\n\t\t\t\t\t// remove [...] constructs\n\t\t\t\t\tfinalName = finalName.replace(/\\[.*?\\]/g, '');\n\t\t\t\t\tif (!fs.existsSync(path.join(basePath, finalName))) {\n\t\t\t\t\t\tfs.copyFileSync(path.join(templatesPath, obj.name), path.join(basePath, finalName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function deactivate() {}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","disposable","vscode","commands","registerCommand","filePath","workspace","rootPath","STRUCTURE_FILE","templatesPath","TEMPLATES_FOLDER","fs","readFile","err","data","window","showErrorMessage","structure","JSON","parse","createFolders","subscriptions","push","basePath","key","value","folderPath","path","join","existsSync","mkdirSync","createTemplate","template","fileName","readdir","withFileTypes","objects","obj","newTemplatePath","name","isDirectory","newPath","replace","finalName","copyFileSync","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}